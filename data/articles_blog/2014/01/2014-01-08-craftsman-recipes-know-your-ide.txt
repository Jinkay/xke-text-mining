2014-01-08-craftsman-recipes-know-your-ide|Craft|  Pour coder tous les jours, vous avez un ou plusieurs éditeurs favoris. Mais pourquoi celui-ci plutôt qu’un autre ?  Je suis obligé car c’est installé sur le poste et je n’ai pas les droits administrateurs ! Je l’utilise depuis toujours et pourquoi je changerai ? Je l’utilise car je me sens vraiment à l’aise avec. Il rend mon travail pluis fluide et il y a moins de barrière entre ce que je pense et ce que je produis.  Que ce soit pour une de ces raisons ou bien d’autres, on se doit de connaître ses outils. Cela le rend souvent plus intéressant et permet d’enlever certaines frustrations. Que ce soient vim, emacs, Sublime Text2, Eclipse, Intellij, NetBeans ou XCode, ils ont chacun leurs points forts pour des cas d’utilisations ciblés et peuvent nous faire gagner du temps tous les jours. Choisir un IDE est souvent sujet à troll velu. Sans vouloir lancer de polémique, je vous propose un retour sur deux ans passés avec IntelliJ sous MacOS chez mon client. Les raccourcis que je présente sont aussi présents dans les autres systèmes d’exploitation. Il suffit souvent de remplacer ⌘(CMD) par CTRL. N’hésitez pas à vous référer aux cheat-sheets de l’outil pour en savoir plus. Pourquoi IntelliJ ? L’intérêt principal du produit n’est pas son thème "Darcula" mais bien son moteur de refactoring.  Je vous présente donc ici une partie des commandes que j’utilise dorénavant tous les jours.    Affectation à une variable locale Raccourci ⌘ + ALT + V Description  Cela permet d’affecter le résultat d’une expression à une variable. C’est très pratique à la déclaration de variable. Je me concentre sur l’objet à créer et je laisse IntelliJ faire l’affectation. Exemple new Amount(15,"EUR");  // ⌘ + ALT + V  Amount amount = new Amount(15,"EUR");      IntelliJ permet de déclarer une variable "final" automatiquement et propose ensuite de la renommer. Même si l’expression à affecter est complexe, il n’est pas nécessaire de sélectionner au curseur la partie à refactorer. IntelliJ vous demande de lever l’ambiguité en vous proposant la partie du code à affecter. Pour l’exemple suivant, il me demande si c’est amount ou amount.format() que je souhaite affecter à une variable. Ce mode de sélection est valable pour tous les refactoring.   Création d’une méthode Raccourci ⌘ + ALT + M Description Refactorez votre code facilement pour le garder lisible ! Cette fonctionnalité rend cette tâche plus simple. Idéal pour refactorer du code complexe ou en mode TDD as you mean it. On peut alors se concentrer sur le code et laisser émerger les méthodes au fur et à mesure des besoins. Le moteur de refactoring est suffisamment intelligent pour vous empêcher d’extraire une méthode qui modifierait deux états à la fois. Cette technique permet donc aussi de travailler le design de l’application et permet de faire des méthodes fortement cohérentes. Exemple public static void main(String[] args) {   final Amount amount_15 = new Amount(15d, "EUR");     final Amount amount_30 = new Amount(30d, "EUR");     final Amount amount_45 = new Amount(amount_15.value + amount_30.value, "EUR");  }    // ⌘ + ALT + M on the equal sign of the third line  public static void main(String[] args) {   final Amount amount_15 = new Amount(15d, "EUR");     final Amount amount_30 = new Amount(30d, "EUR");     final Amount amount_45 = sum(amount_15, amount_30);  }    private static Amount sum(Amount op1, Amount op2) {   return new Amount(op1.value + op2.value, op1.currency );  }     IntelliJ ouvre une boîte de dialogue pour renommer le nom de la méthode ainsi que ses paramètres. Ici, j’ai fait l’extraction depuis une méthode statique, le résultat est aussi statique. Introduction de paramètre Raccourci ⌘ + ALT + P Description Cette fonctionnalité est très puissante quand elle est utilisée avec la commande précédente. Elle permet d’ajouter une expression comme paramètre d’une méthode. IntelliJ simplifie ensuite l’expression au fur et à mesure. Il demande même des valeurs par défaut si dans un des contextes d’appels, aucune variable ne correspond au refactoring demandé. Exemple Ici, je vais refactorer ma dernière fonction "sum" pour ne prendre en paramètres que la devise du premier montant ainsi que les deux valeurs. Pour cela, je clique sur l’expression op1.currency et j’exécute le raccourci. Je réitère sur les deux valeurs des montants et j’obtiens : public static void main(String[] args) {   final Amount amount_15 = new Amount(15d, "EUR");     final Amount amount_30 = new Amount(30d, "EUR");     final Amount amount_45 = sum(amount_15.currency, amount_15.value, amount_30.value);  }    private static Amount sum(String currency, double value_1, double value_2) {   return new Amount(value_1 + value_2, currency);  }     Comme il n’y a plus besoin d’une instance d’Amount, IntelliJ l’a simplement supprimé de la méthode dans la déclaration ainsi que dans l’appel. Changement de signature d’une méthode  Raccourci ⌘ + F6 Description Sur une méthode existante, cela permet d’ajouter, de supprimer, de renommer ou de changer l’ordre des paramètres. Utilisée à la suite de l’extraction de méthode, elle permet d’avoir une signature claire suite à un refactoring. Comme pour le reste, IntelliJ se charge de la réécriture de la signature ainsi que de changer tous les appels à cette fonction. Exemple Je vais ici placer la devise comme troisième paramètre de la fonction sum à l’aide de la boîte de dialogue. La signature la fonction est changée, ainsi que les appels à celle-ci. public static void main(String[] args) {   final Amount amount_15 = new Amount(15d, "EUR");     final Amount amount_30 = new Amount(30d, "EUR");     final Amount amount_45 = sum(amount_15.value, amount_30.value, amount_15.currency);  }    private static Amount sum(double value_1, double value_2, String currency) {   return new Amount(value_1 + value_2, currency);  } Renommer des éléments  Raccourci ⇧ + F6 Description Cela permet de renommer presque tous les éléments dans l’IDE, variable, paramètre, classe, attribut, classe, fichier… Si l’élément renommé est une variable d’instance, IntelliJ se propose de s’occuper aussi des getter/setter ainsi que des paramètres de constructeurs. Exemple class Amount {   private final double value;   private final String currency;     private Amount(double value, String currency) {    this.value = value;    this.currency = currency;   }     public double getValue() {    return value;   }  }   Je décide de renommer la variable d’instance value en val (une mauvaise idée à vrai dire !). class Amount {   private final double val;   private final String currency;     private Amount(double val, String currency) {    this.val = val;    this.currency = currency;   }     public double getVal() {    return val;   }  } Sélection de code Raccourci ⌘ + W Description C’est devenu un outil indispensable ! Il permet de sélectionner des blocs de code toujours cohérents et de façon incrémentale. Cela fonctionne dans tous les types d’éditeurs d’IntelliJ et donc pour quasiment tous les langages supportés par l’IDE. Pour faire du copier/coller, du refactoring ou de la suppression de code, c’est idéal ! Exemple Si je place mon curseur sur l’expression "val" de "return val" du getter, voici ce qu’IntelliJ va sélectionner au fur et à mesure.  val return val; toute la ligne avec "return val;" {return val;} public double getVal() {return val;} Les trois lignes complètes de cette méthode Tout Le contenu de la classe: Puis toute la classe avec sa définition  Puis tout le fichier et il s’arrêtera là. Je ne me passe plus de cette commande. C’est devenu un réflexe que je souhaite utiliser dans d’autres applications sous MacOS. Convert Anonymous Class to Inner Class Raccourci Il n’y en a pas, il faut aller dans le menu Refactor/ Convert Anonymous to Inner … Description Cela permet de transformer une classe anonyme en classe interne. C’est bien pratique lorsque l’on travaille avec des librairies comme Guava et que l’on a souvent besoin de Function et Predicate. On laisse IntelliJ créer la classe anonyme à la volée, puis on peut la refactorer dans une classe interne. Exemple public static void main(String[] args) {   final Amount amount_15 = new Amount(15d, "EUR");   final Amount amount_30 = new Amount(30d, "EUR");     from(newArrayList(amount_15, amount_30))    .transform(new Function<Amount, Double>() {     @Nullable     @Override     public Double apply(@Nullable Amount input) {      return input == null ? null : input.getVal();     }    });  }  //After refactoring  public static void main(String[] args) {   final Amount amount_15 = new Amount(15d, "EUR");   final Amount amount_30 = new Amount(30d, "EUR");     from(newArrayList(amount_15, amount_30))    .transform(new ToValue());  }    private static class ToValue implements Function<Amount, Double> {   @Nullable   @Override   public Double apply(@Nullable Amount input) {    return input == null ? null : input.getVal();   }  } Déplacer des éléments  Raccourci F6 Description Permet de déplacer à peu près tout, une classe dans un autre package, un variable ou méthode d’instance d’une classe à une autre. Cela permet aussi de passer d’une classe interne à une classe de premier niveau. Exemple Je peux par exemple déplacer ma fonction interne "ToValue" pour l’isoler dans son fichier ce qui la rend plus facilement testable et réutilisable. Inline Raccourci ⌘ + ALT + N Description C’est certainement l’une des commandes les plus bluffantes. Elle permet d’inliner une variable, une méthode et même une classe dans certains cas d’héritage ! C’est idéal pour supprimer des variables ou des méthodes redondantes. Je pourrais ici revenir en arrière sur mon précédent refactoring et réintégrer ma fonction comme un type anonyme. Je peux aussi déplacer l’initialisation de mes montants de tests directement dans l’initialisation de la liste. public static void main(String[] args) {   final Amount amount_15 = new Amount(15d, "EUR");   final Amount amount_30 = new Amount(30d, "EUR");     from(newArrayList(amount_15, amount_30))    .transform(new ToValue());   }    //After refactoring  public static void main(String[] args) {   from(newArrayList(new Amount(15d, "EUR"), new Amount(30d, "EUR")))    .transform(new ToValue());  } I need Help, le Quick Fix d’IntelliJ Raccourci ALT + ENTER Description Impossible de couvrir ici tout ce que fait cette commande. Elle est très contextuelle et permet de faire énormément de choses, corriger des erreurs de compilations, importer des classes, refactorer des expressions booléennes, ajouter des expressions en imports statiques, créer une valeur d’instance et y affecter la référence d’un paramètre du constructeur non utilisé… Associer au système de warning, il permet de corriger des erreurs de style de code en évitant ainsi quelques bugs au passage ! A essayer de toute urgence ! Conclusion Ces commandes sont celles que j’utilise tous les jours. Elles me permettent de pouvoir refactorer du code sans trop de soucis. Je peux ainsi me concentrer sur ce que doit faire le code et laisse l’IDE s’occuper de lui faire respecter mes souhaits de conception.En mode "TDD as you mean it", on code directement le code de production dans la classe de test. On laisse émerger une classe quand le besoin s’en fait sentir et on refactore ensuite avec la batterie de tests comme ceinture de sécurité. Sans outillage, cette démarche s’avère longue et périlleuse.  Dans IntelliJ, il y a un élément intéressant du menu dans Help/ Productivity Guide. Il vous informe de votre utilisation de l’IDE.  Comment s’entrainer? Organisez des coding dojo avec une session où l’utilisation de la souris est proscrite. Vous pouvez encore utiliser le plugin KeyPromoter pour vous entraîner, ou encore la commande ⌘ + ALT + A qui permet d’accéder à toutes les fonctionnalités d’IntelliJ par leur nom en affichant en plus le raccourci associé. Il est facile de se rendre compte de l’importance de ces raccourcis quand on aime coder. On le voit rapidement chez Xebia lors d’un Dojo ou d’une journée interne XKE (Xebia Knowledge Exchange):  Eclipse ou IntelliJ QUERTY ou AZERTY (les équipes de Code-Story peuvent en témoigner ;-)) Windows, MacOS ou une Linux, sous MacOS, sens "naturel" ou pas d’utilisateur du trackpad, et comment faire un clic droit sur le pad ?   Travailler sur un environnent qui n’est pas le sien devient très compliqué et frustrant. Notre environnement de travail doit refléter la manière dont nous pensons et travaillons quotidiennement. Il ne fera pas du code propre à votre place, mais vous aidera à le faire si vous le souhaitez vraiment. A vous de construire votre environnement de travail, dans la mesure du possible, et éclatez vous avec vos outils. Ils sont là pour ça ! 