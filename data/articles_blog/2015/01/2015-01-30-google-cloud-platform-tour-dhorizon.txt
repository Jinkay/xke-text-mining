2015-01-30-google-cloud-platform-tour-dhorizon|Cloud|  A l’occasion du DevFest Paris où nous sommes sponsors, nous vous proposons de (re-)découvrir l’article   Google Cloud Platform : Tour d’horizon   publié dans le magazine Programmez. Ces 2 dernières années, Google a multiplié les annonces autour de sa plateforme Cloud. Toutefois, celle-ci existe depuis bien plus longtemps puisque la plateforme App Engine est proposée depuis mi 2008. Quels ont été les changements entrepris en 2 ans pour que la plateforme Cloud de Google devienne incontournable ? Qu’apporte-t-elle aux développeurs ? C’est ce que nous allons détailler dans cet article.  Google Cloud Platform : Tour d’horizon L’offre de Google Cloud s’articule en 3 axes :  Le compute. Il regroupe App Engine et Compute Engine. Il permet de faire tourner votre code. Le storage. Il regroupe des bases de données comme DataStore, Cloud SQL et Cloud Storage pour stocker les données et les fichiers. Les services. Développés par Google, ils apportent de nouvelles fonctionnalités sans ajouter de développement : des services “clefs en main”. Cela va de l’exposition d’une API REST facilitée via Cloud Endpoint à la gestion de DNS avec Cloud DNS.    Compute  Historiquement, l’offre compute de Google a commencé en 2008 avec App Engine, représentant son offre PAAS (Platform As A Service). App Engine vous permet d’écrire votre code en Java/PHP/Go/Python et en une commande de le déployer en production. Votre application est alors totalement managée par les ingénieurs Google pour garantir sa disponibilité et sa stabilité. Cependant, App Engine renvoie une mauvaise image avec son Lockin qui impose l’utilisation de certaines classes uniquement : il faut adapter votre code à la plateforme. Cette limite tend à disparaître avec les Managed VMs. Nous reviendrons sur cette évolution.  L’autre pan du compute est Compute Engine (GCE), la plateforme IAAS (Infrastructure As A Service) de Google, annoncée il y a 2 ans. Compute Engine permet de créer une infrastructure complète pour vos traitements avec gestion du réseau, firewalls, load balancing et storage. On peut aussi instancier des VMs pour y mettre ce que l’on veut. Compute Engine est encore jeune mais au fil des semaines propose de plus en plus de fonctionnalités aussi bien pour les opérationnels que pour les développeurs.  Storage La plateforme Google propose 3 solutions de stockages : – DataStore : une base de données NoSQL. Egalement disponible sur Compute Engine, c’est un service indépendant permettant de stocker vos données de manière transactionnelle, sans schéma. Google se charge de la réplication et de la scalabilité pour vous. – Cloud SQL : un MySQL dans le Cloud ! Vous pouvez vous servir de cette base comme de n’importe quelle base MySQL. Les drivers, scripts et autres outils que vous avez déjà mis en place avec une base de données MySQL fonctionnent également. Comme pour le DataStore, Google se charge de votre réplication et de la scalabilité. – Cloud Storage : un système de fichiers dans le Cloud. Vous pouvez stocker vos fichiers directement dans le Cloud. Le système gère le versionnage des fichiers. Comme pour les autres services, Google assure la réplication et la disponibilité des données. Services La liste des services proposés par la plateforme s’élargit au jour le jour. Les principaux sont : – BigQuery : service de stockage et de requêtage interactif orienté Big Data. Impressionnant par ses performances, le service vous permet de requêter des tera octets de données en quelques secondes grâce à un langage de requêtage ressemblant fortement à SQL. – Cloud Endpoint : service disponible dans AppEngine qui permet d’exposer une API REST de manière simplifiée. Il permet de générer des snippets de code aussi bien web, que Java ou mobile. – Cloud DNS : service de DNS configurable via une API hébergé directement dans le réseau Google. Vous profiterez alors des performances du réseau Google. Liens utiles :  https://cloud.google.com/ : Homepage de Google Cloud    Le Google Cloud, quel intérêt pour les développements ? Les développements ? Mais dans quel langage ? Les intéractions avec le Google Cloud peuvent se faire de 2 manières : via la console web ou l’API REST. Pour vous simplifier la tâche, Google a créé une multitude de clients de l’API REST en Java, Python, Go, PHP, JavaScript, etc. Nous nous focaliserons sur l’approche Java pour App Engine et ligne de commande via l’outil Google Cloud SDK (écrit en Python) pour Compute Engine. App Engine Comme évoqué ci-dessus, App Engine représente l’offre PAAS de Google Cloud. Pour déployer une application sur cette plateforme, il suffit d’envoyer l’application packagée (.war pour une application Java). La suite est automatisée : déploiement, scaling, monitoring, etc. Il existe malgré tout quelques règles à respecter. Les runtimes Les runtimes de App Engine sont l’équivalent d’un serveur d’application. Ils viennent avec leur lot de services disponibles et il suffit de coder les intéractions avec ceux-ci. Il existe 4 runtimes : Java, Python, PHP (en preview) et Go (en experimental). NodeJS serait le 5eme runtime disponible prochainement. En Java, vous pouvez créer puis déployer une application très rapidement. Par exemple, avec Maven (3.1 minimum) vous créez une nouvelle application avec la commande suivante :   mvn <a href="http://archetypegenerate" rel="nofollow">archetype:generate</a>   -DarchetypeGroupId=com.google.appengine.archetypes -DarchetypeArtifactId=skeleton-archetype -DarchetypeVersion=1.7.5   Une fois l’application créée, actualisez la avec la dernière version du runtime Java de Google App Engine (GAE) dans le pom.xml à l’aide de la propriété appengine.target.version (par exemple 1.9.7). Ensuite, créez une servlet : public class HelloWorldServlet extends HttpServlet {    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {    resp.getWriter().print("HelloWorld");    }    }     Mettez à jour le fichier web.xml : <servlet>    <servlet-name>HelloWorld</servlet-name>    <servlet-class>fr.xebia.programmez.HelloWorldServlet</servlet-class>    </servlet>    <servlet-mapping>    <servlet-name>HelloWorld</servlet-name>    <url-pattern>/helloworld</url-pattern>    </servlet-mapping>   Enfin, pour tester en local, il suffit de lancer la commande mvn appengine:devserver, puis d’aller sur http://localhost:8080/helloworld pour voir le helloworld s’afficher. Pour le déploiement de votre helloworld sur les serveurs de Google, il faut tout d’abord créer un projet dans la console https://console.developers.google.com/project. Une fois créé, notez le “Project ID”  que Google vous a attribué et copiez-le dans le fichier appengine-web.xml dans le tag <application>. Il ne reste plus qu’à lancer la commande mvn appengine:update pour déployer l’application. Une fois terminé, allez sur http://<Project ID>.appspot.com/helloworld pour afficher votre beau helloworld. Les services et les outils Pour le stockage des données de votre application, GAE propose d’utiliser sa solution nommée “DataStore”, une base de données NoSQL utilisant Bigtable. Vous pourrez également utiliser une base de données relationnelle (MySQL) si nécessaire. Toutefois, l’utilisation de cette dernière ne fait pas partie du quota gratuit quotidien. Dans le framework, GAE fournit un ensemble de services :  un système de queue permettant de déporter les tâches longues dans des processus séparés, un service de cache (memcache), un service capabilities vous permettant d’interroger l’état en temps réel des services GAE afin de prévoir une alternative si un problème ou une maintenance sont identifiés, un service channel pour faire du push vers des clients JavaScript, un service d’indexation/recherche de documents avec la possiblité d’indexer des points géolocalisés, en plus des classiques date, texte, etc. le service “Endpoint” qui vous permet de développer rapidement une API accessible grâce à des clients générés pour iOS, Android ou JavaScript, la gestion OAuth des utilisateurs Google.  Concernant les outils de développement, Google met à disposition un plugin Eclipse pour le runtime Java. Pour le développement d’une API avec le service Endpoint, vous pourrez utiliser l’IDE Android Studio s’appuyant sur IntelliJ. De manière plus générale, vous pourrez utiliser un plugin Maven permettant d’être agnostique de l’IDE utilisé. Dans les fonctionnalités à venir, Cloud Debugger est un outil pouvant se révéler puissants pour un PAAS comme GAE. Il permettra de poser des break points dans votre code via la console de GAE, de vérifier les valeurs, de débugger votre application en direct et cela, même si celle-ci est répartie sur plusieurs instances. Cloud Debugger est pour le moment accessible en tests après acceptation de Google . Push to deploy La fonctionnalité “push to deploy” ou “release pipeline” initialement accessible pour Python et PHP est depuis peu disponible pour Java. Pour fonctionner, Google va créer une instance Jenkins dans la partie Compute de votre projet. Après chaque push vers votre repository GitHub (ou un repository GIT spécifiquement hébergé par Google), il lancera automatiquement le build, les tests et le déploiement vers App Engine. Vous l’aurez compris, pour les projets Java, il vous faudra autoriser la facturation pour financer l’instance Jenkins. A noter que pour les plus petits projets, il est possible de désactiver ponctuellement la fonctionnalité. Concernant l’utilisation de cette fonctionnalité, Google doit être autorisé à accéder à votre code en créant soit un repository GIT hébergé par Google, via la console Google Cloud, soit en autorisant l’accès à un repository GitHub. Vous aurez alors accès au code source à partir de la console web (cf screenshot).    Edition de code dans la console web de Google Cloud   Vous pouvez maintenant éditer directement votre code dans la console et valider les modifications dans le repository GIT. En activant l’option “Use Maven to build test and deploy”, le serveur Jenkins lancera à chaque commit le build, les tests et finalement le déploiement sur App Engine. Le Lockin et le sandbox Un runtime GAE représente un langage et un framework qui permettent de développer des applications scalables. Cependant, avec la dépendance de ce framework, vous ne pourrez plus déployer votre application ailleurs que dans les serveurs GAE. Ce problème de Lockin dénoncé par de nombreux développeurs a fait réagir Google qui a répondu avec un TCK (Technology Compatibility Kit) pour le framework GAE. Celui-ci permet alors d’implémenter sa propre version alternative et compatible : déployer ailleurs que chez Google est maintenant possible, le projet CapeDwarf de Red Hat en est un exemple.   En plus du Lockin, les runtimes s’exécutent dans un “sandbox” appliquant des limitations afin d’assurer la sécurité et la scalabilité des applications développées (pas d’accès au systeme de fichier, manipulation des threads limités, etc.). Les Managed VMs      Pour les raisons citées précédemment dans “Le Lockin et le sandbox”, Google propose une alternative qui ambitionne de combiner l’aspect PAAS de Google App Engine (GAE) et la souplesse de Google Compute Engine (GCE) : les Managed VMs. Grâce aux Managed VMs, on peut maintenant avoiraccès à un runtime standard tout en profitant des avantages d’App Engine (monitoring, scalabilité, services…) Reprenez votre helloworld et modifiez-le pour afficher le résultat de la commande “uname -a” qui permet de présenter les informations de l’OS où se trouve la JVM : protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {    Process p = Runtime.getRuntime().exec("uname -a");    BufferedReader b = new BufferedReader(new InputStreamReader(p.getInputStream()));    resp.getWriter().print(b.readLine());    }     Lorsque que l’on éxécute ce code dans App Engine, on obtient une erreur : HTTP ERROR 500 Problem accessing /helloworld. Reason:    access denied ("java.io.FilePermission" "<<ALL FILES>>" "execute")    Caused by:    java.security.AccessControlException: access denied ("java.io.FilePermission" "<<ALL FILES>>" "execute")  at java.security.AccessControlContext.checkPermission(AccessControlContext.<a href="http://java:457" rel="nofollow">java:457</a>)  at java.security.AccessController.checkPermission(AccessController.<a href="http://java:884" rel="nofollow">java:884</a>)  at java.lang.SecurityManager.checkPermission(SecurityManager.<a href="http://java:549" rel="nofollow">java:549</a>)    [...]     Le Lockin nous empêche d’accéder à la classe FilePermission. Avec les Managed VMs, cette limite est levée. Pour activer la création d’une instance App Engine en mode Managed VMs, il vous suffit de rajouter dans le fichier appengine-web.xml la ligne : <vm>true</vm>   Maintenant, lorsque l’on exécute le code précédent, on a bien le résultat de la commande “uname -a”. Ceci n’est qu’un exemple simpliste mais l’accès à un vrai runtime rend App Engine beaucoup plus souple. Il donne la possibilité de rendre des frameworks, tel que Grails, utilisables dans AppEngine et vous donne accès à des machines avec plus de CPU et de mémoire. Enfin dans un avenir proche, App Engine gérera les runtimes custom donnant une totale liberté tout en conservant les avantages d’App Engine ! Liens utiles :  https://developers.google.com/appengine/ : documentation de App Engine https://github.com/GoogleCloudPlatform/appengine-java-vm-hello : exemple helloworld    Compute Engine Compute est la partie IAAS du Google Cloud. Vous allez pouvoir créer votre infrastructure complète avec la création de réseaux, firewalls, load balancers, et machines virtuelles. Pour la réaliser, vous pouvez passer par la console web, l’outil Google Cloud SDK, ou encore, REST. Google Cloud SDK : l’outil couteau suisse Pour faciliter la vie du développeur, Google propose l’outil Google Cloud SDK. C’est un utilitaire en ligne de commande permettant d’interagir très facilement avec Compute Engine, App Engine et les autres services Google Cloud. Cet outil se télécharge à l’adresse suivante : https://developers.google.com/cloud/sdk/. S’authentifier une fois pour toute Une authentification est nécessaire pour accéder aux APIs Google Cloud. Celle-ci se fait en exécutant la commande :  gcloud auth login Cette commande va permettre à l’outil de se brancher à votre compte Google et de vous authentifier de manière transparente pour toutes vos opérations avec le Google Cloud. Il peut également être pertinent de persister le nom de projet pour éviter de le saisir à nouveau à chaque commande :  gcloud config set project MY_PROJECT_NAME Scripter la création de VM Compute Engine Le Google Cloud SDK vous permet en une simple ligne de commande de créer une instance Compute Engine :  gcutil addinstance my-first-instance --machine_type=n1-standard-2 --image=debian-7 --zone=us-central1-a --wait_until_running --auto_delete_boot_disk Dans le détail : – gcutil : est l’outil pour interagir avec Compute Engine. – addinstance : indique à Compute Engine que l’on veut créer une instance. – –machine_type : définit le type d’instance souhaitée. Il existe actuellement 4 grandes familles d’instances :  instances standards (préfixées par n1-standard) : machines non spécialisées à utiliser pour des traitements n’ayant pas de besoins particuliers, instances high memory (préfixées par n1-highmem) : machines spécialisées pour les traitements gourmands en mémoire, instances high CPU (préfixées par n1-highcpu) : machines faîtes pour les traitements très gourmands en CPU, instances avec partage de CPU : machines faîtes pour les petits traitement. Très utiles pour les tests en début de projet car très peu onéreuses.    Pour avoir la liste complète des types d’instance, vous pouvez utiliser la commande : gcutil listmachinetypes – –image : affiche le type d’O.S utilisé par l’instance. Actuellement 4 O.S. sont supportés : Debian 7, CentOS 6, Red Hat 6 et SuSE Linux 11. Pour avoir la liste des différentes images : gcutil listimages. Il est possible de créer soit même ses images. – –zone : définit la zone dans laquelle votre instance sera. La position géographique de la zone est importante car plus elle sera proche, moins la latence réseau sera importante. Il existe des régions en Europe, USA, et Asie. gcutil listzones : permet de lister les zones disponibles. – –wait_until_running : précise que l’on souhaite attendre que l’instance soit bien créée avant de rendre la main. – –auto_delete_boot_disk : permet de supprimer le disque dur de l’instance dès que celle-ci est eteinte. Accéder en SSH à une instance Compute Engine Pour accéder à une instance Compute Engine, Gcutil nous fournit une commande :  gcutil ssh my-first-instance Cette commande n’est que l’alias d’une commande SSH standard mais elle permet d’accéder directement à la machine souhaitée. Mieux encore, si votre environnement n’est pas encore créé, la commande va vous générer une clef SSH et va la répliquer sur le Google Cloud pour accéder à toute nouvelle machine. Liens utiles :  https://developers.google.com/cloud/sdk/ : Homepage Cloud SDK http://googlecloudplatform.blogspot.fr/2014/03/tips-and-tricks-command-line-access-to.html : tips & tricks Cloud SDK  Deployment Manager : automatiser l’installation de votre architecture Lorsqu’on se connecte sur une instance Compute Engine, il n’y a que l’O.S. Pas de logiciel tiers installé, encore moins vos applicatifs. Pour pouvoir automatiser l’installation d’une machine, vous pouvez faire un snapshot d’une instance déjà installée et la dupliquer. Cependant, la maintenance est généralement assez compliquée (mise à jour d’un applicatif, changement de paramètres, etc). D’autres problématiques telles que la création de vos règles de load balancing, firewall et la gestion du scaling peuvent se présenter. Pour y répondre, le Deployment Manager a été créé. Le Deployment Manager est un service qui permet, à partir d’un fichier de configuration JSON ou YAML, de créer une ressource. Il existe 5 types de ressources : – LOAD_BALANCING (lbModule) : crée des règles de load balancing, – HEALTH_CHECK (healthCheckModule) : crée des règles pour vérifier l’intégrité de vos applicatifs, – FIREWALL (firewallModule) : gère les règles d’accès réseau à vos machines, – REPLICA_POOL (replicaPoolModule) : crée une batterie d’instances de même type à partir d’une seule configuration, – AUTOSCALING (autoscalingModule) : gère des règles pour démarrer ou arrêter des instances sans intervention. Pour mieux comprendre, prenons un fichier de description YAML mettant en place une architecture comprenant les éléments suivants : – des serveurs NodeJS deployés sur des instances Compute Engine, – un load balancing entre ces serveurs, – un health check vérifiant que les serveurs sont disponibles, – une règle firewall pour ouvrir le port 8080, – une règle d’auto-scaling créant une nouvelle instance dès que celle-ci arrive à 80% de CPU. Le fichier de description YAML commence par un header donnant un nom à notre déploiement : name: my-first-deployment  description: Mon premier déploiement  modules:  #Tous mes modules ici Déclarer un replica pool Voici la déclaration en elle-même :   nodejs:  type: REPLICA_POOL  replicaPoolModule:  numReplicas: 2  replicaPoolParams:  v1beta1:  machineType: n1-standard-1  zone: us-central1-a  baseInstanceName: nodejs  disksToCreate:  - boot: true  initializeParams:  sourceImage: #url vers image  diskSizeGb: 100  initAction: install  networkInterfaces:  - network: default  accessConfigs:  - name: External NAT  type: ONE_TO_ONE_NAT  envVariables:  PORT:  value: 8080     – nodejs : le nom donné au module. – type : le type de module. Ici, nous définissons un REPLICA_POOL. Ce module crée des instances identiques. – replicaPoolModule : début de déclaration du module. – numReplicas : le nombre d’instances à créer. – v1beta1 : la version du module utilisée. – machineType : le type d’instances Compute Engine à démarrer. – baseInstanceName : le préfixe des noms d’instance. Le nom final d’une instance sera quelque chose comme nodejs-<chaine de caractères aléatoire>. – disksToCreate : Définition le disque dur à utiliser. – boot : indication sur le disque dur souhaité est bootable. – initializeParams : les paramètres pour initialiser le disque. – sourceImage : l’url vers l’image OS. Si on veut une debian par exemple, l’url est https://www.googleapis.com/compute/v1/projects/debian-cloud/global/images/debian-7-wheezy-v20131120. – diskSizeGb : la taille du disque en Go. – initAction : référence vers une action à lancer une fois l’instance démarrée. – networkInterfaces : définition de la partie réseau. – network : le nom du réseau à utiliser. – accessConfigs : définition d’un accès. Les valeurs ici sont toujours les mêmes dans cette version. S’il n’y a pas d’accessConfigs définit, l’instance n’aura pas d’accès Internet. – envVariables : définition des variables d’environnement à la machine. Ici, on définit la valeur du port de NodeJS.   Dans la définition de ce module, on référence l’action install. Une action est un ensemble de commandes linux qui est lancé après le démarrage de votre instance. La définition d’une action se place après les modules dans notre fichier.   actions:    install:    commands: [    "wget -O nodejs.tar.gz <a href="http://nodejs.org/dist/v0.10.29/node-v0.10.29-linux-x64.tar.gz" rel="nofollow">http://nodejs.org/dist/v0.10.29/node-v0.10.29-linux-x64.tar.gz</a>",    "tar -xzf nodejs.tar.gz",    "cp node-v0.10.29-linux-x64/bin/* /usr/local/bin/",    "cp -r node-v0.10.29-linux-x64/lib/* /usr/local/lib/",    "%<a href="http://filesetup-node.sh" rel="nofollow">file:setup-node.sh</a>",    "/usr/local/bin/node /srv/www/hello.js"    ]        Dans cette définition, il n’y a que des commandes Linux standards à l’exception de   %file:setup-node.sh   qui permet de référencer un fichier externe. Ici un script SH va générer un fichier JS pour démarrer votre node :   DIR=/srv/www    FILE=hello.js    mkdir -p $DIR    cat <<EOF >$DIR/$FILE    var http = require('http');    var server = http.createServer(function (request, response) {    response.writeHead(200, {"Content-Type": "text/html"});    response.end("<html><body>Hello World</body></html>");    });         server.listen($PORT);    EOF         chmod a+r $DIR/$FILE Déclarer un load balancing load_balancer:    type: LOAD_BALANCING    lbModule:    ipAddress: 1.2.3.106    ipProtocol: TCP    portRange: 200-65535    targetModules: [    nodejs    ]     – load_balancer : le nom du module de load balancing. – type : le type de module. – lbModule : debut de déclaration du module. – ipAddress : l’IP du load balancer. Si on ne définit pas ce paramètre, l’IP sera automatiquement assignée. – ipProto : on peut faire un load balancing sur différents types de protocole. Par défaut, ce sera TCP. – portRange: la plage de port que l’on veut load balancer. Si on ne définit pas ce paramètre, tout le trafic sera load balancé. – targetModules : où pointe le load balancing. Dans notre cas, ce sera sur vos instances NodeJS. Déclarer un health check health_check:    type: HEALTH_CHECK    healthCheckModule:  <p style="margin-left: 36.0pt;">host: 1.2.3.106</p>  <p style="margin-left: 36.0pt;">path: /</p>  <p style="margin-left: 36.0pt;">port: 8080</p>  <p style="margin-left: 36.0pt;">checkIntervalSec: 5</p>  <p style="margin-left: 36.0pt;">timeoutSec: 5</p>  <p style="margin-left: 36.0pt;">unhealthyThreshold: 2</p>  <p style="margin-left: 36.0pt;">healthyThreshold: 2</p>      – health_check : nom du module, – type : type du module, – healthCheckModule : définition du healthCheckModule, – host : url ou IP que le health check doit appeler (ici, on définit l’IP de notre load balancer), – path : le chemin à tester, – checkIntervalSec : fréquence en seconde d’appel, – timeoutSec : temps en seconde au bout duquel l’appel est considéré en timeout, – healthyThreshold & unhealthyThreshold : nombre de fois où le test est ok (ou ko) avant de déclarer une instance up (ou down).   Déclarer un firewall firewall:    type: FIREWALL    firewallModule:    network: default    sourceRanges: [ 0.0.0.0/0 ]    allowed: [ {    IPProtocol: tcp,  ports: [ 8080 ]    } ]   – firewall : nom du module, – type : type du module, – firewallModule : définition du firewallModule, – network : le network concerné par notre règle, – sourceRanges : plages d’IP depuis lesquelles on accepte du trafic, – allowed : définition du trafic que l’on accepte. Déclarer de l’auto scaling webserver_autoscale:  type: AUTOSCALING  autoscalingModule:  minNumReplicas: 2  maxNumReplicas: 6    targetUtilization: 0.8  signalType: AVG_CPU  targetModule: nodejs – webserver_autoscale : nom du module d’auto scaling, – type : type du module, – autoscalingModule : définition du autoscalingModule, – minNumReplicas : nombre minimum de replica de l’architecture, – maxNumReplicas : nombre maximum à attendre (il s’agit d’une pratique pour plafonner, car plus on aura d’instance plus on payera), – targetUtilization : de 0 à 1, permet de mettre un niveau d’utilisation du CPU (ici 80%), – signalType : actuellement, seulement AVG_CPU est supporté, qui correspond à la charge CPU, – targetModule : définition du module qui doit être repliqué.   Lancer le déploiement Vous pouvez maintenant lancer le déploiement. Il s’effectue en 2 étapes. Etape 1 : Enregistrer son template dans le Deployment Manager en effectuant la commande suivante :  gcloud preview deployment-manager templates create --template-file my-first-deployment.yaml mynewtemplate On enregistre avec cette commande notre fichier YAML my-first-deployment.yaml sous le nom mynewtemplate au sein du Deployment Manager. Avec cette commande, il y a aussi une validation syntaxique de votre fichier. Etape 2  : Lancer le déploiement avec cette commande : gcloud preview deployment-manager deployments --region us-central1 create --template mynewtemplate nodejs_deployment Vos composants vont être créés au sein de Compute Engine. Votre architecture est maintenant prête ! Lien utile :  https://developers.google.com/deployment-manager/ : Home Deployment Manager    Combien ça coûte ?   La problématique du coût est récurrente lorsque que l’on parle de Cloud. Pour une meilleure compréhension du coût de Compute Engine, Google a mis en place un price calculator. Vous pouvez le trouver ici : https://cloud.google.com/products/calculator/   Donnons l’exemple d’une infrastructure de base dans l’auto scaling. Même si l’auto scaling n’est pas pris en compte, celà permet d’avoir une bonne idée du prix de l’infrastructure. Docker, Kubernetes et le Google Cloud Association de Docker et Google Compute Engine (GCE)    Docker est une révolution dans le monde de la virtualisation, Google fait partie de ceux qui placent beaucoup d’espoirs dans cette technologie. Exploitant les possibilités offertes par Linux, en particulier LXC et CGroup, Docker permet de déployer des containers : machines virtuelles n’embarquant pas de système d’exploitation, mais exploitant les ressources du système hôte directement. Les avantages retirés sont l’allégement et l’accélération du déploiement de container. Il est donc possible de déployer sur GCE une VM avec un Docker prêt à l’emploi et un agent permettant de monitorer les containers. La commande suivante permet de déployer ladite VM : gcloud compute instances create docker-instance --image container-vm-v20140710 --image-project google-containers --zone europe-west1-a --machine-type f1-micro   Une fois l’instance démarrée, connectez-vous dessus à l’aide de la commande Gcutil SSH, vous pourrez vérifier que Docker est bien présent : $ gcutil ssh docker-instance  docker-instance$ sudo docker info    Cette instance est prête à héberger des containers Docker. On parle cependant d’une seule instance. Plutôt que de lancer vos instances puis vos containers sur chacune d’entre elles, il serait préférable de travailler avec un cluster d’instances GCE. Kubernetes Google a une certaine expérience avec les containers puisque toutes ses applications sont packagées dans ces derniers : le service de recherche, Gmail, etc. Pour déployer et assurer la scalabilité de ses services, Google utilise son propre système : Omega. Omega est néanmoins un système trop complexe et surtout trop critique pour être mis à disposition du grand public. Google a donc décidé de développer un nouvel outil, Kubernetes, qui permet de gérer un cluster de containers. Toujours en version bêta, Kubernetes se veut très ouvert afin d’être enrichi par la communauté et s’adapter à d’autres plateformes que le Cloud de Google. Ce système est capable de travailler avec Vagrant, mais aussi avec le Cloud de Microsoft, Azure. Dans cette aventure, Google a réussi à entrainer avec lui Microsoft, IBM, Red Hat et, bien sûr, Docker. L’atout de Kubernetes est de fournir des mécanismes de redémarrage automatique, d’ordonnanceur et de réplication faisant de lui plus qu’un simple orchestrateur. Cette version bêta, comme tout nouveau projet, manque encore de documentation. On trouve néanmoins sur le GitHub du projet des exemples à dérouler qui nous donnent un aperçu des possibilités de Kubernetes, en particulier l’exemple Guestbook. Après le démarrage d’un cluster d’instances composé d’un master et quatres “minions”, Kubernetes se montre capable de déployer plusieurs containers dans le cluster. Le choix de la répartition entre les instances est décidé par Kubernetes. D’après Google, cet algorithme de répartition sera amélioré à terme afin de prendre en compte la charge des machines notamment. En supposant que vous avez déjà un compte GCE configuré, il vous suffit de cloner le projet GitHub de Kubnernetes et de lancer la commande suivante : $ cluster/kube-up.sh Cela va créer un cluster sur GCE avec la configuration suivante :  Architecture du cluster Kubernetes Un master est alors créé ainsi que quatre minions. Vous pouvez alors interagir avec le cluster via l’outil en ligne de commande cluster/kubecfg.sh. Pour le détruire :  $ cluster/kube-down.sh Fonctionnement de Kubernetes Master instance Le masterest composé d’une API permettant de gérer trois ressources principales qui sont :  Pods, replication controllers, services.  Minion instance Sur chaque minion, Docker est disponible et permet d’exécuter des containers. Ces derniers, s’ils sont fortement liés entre eux (i.e. des containers qui doivent interagir ensemble, scaler ensemble) sont rassemblés au sein d’une unité nommée Pod. Les minions vont alors contenir un ou plusieurs pods, chacun constitué d’un ou plusieurs containers Docker. Un autre composant est également installé sur chaque minion : Kubelet. Cet agent a pour rôle de s’assurer que le Pod est bien bien configuré, démarré et stable dans sa configuration lorsqu’il fonctionne. La configuration en question est décrite à l’aide de fichiers manifest décrits au format YAML (https://developers.google.com/compute/docs/containers/container_vms#container_manifest). Label Il est possible d’affecter des labels aux Pods afin de faciliter la configuration des services ou des replication controllers. Ces derniers disposent dans leur configuration d’une propriété label selector qui permet d’affecter des Pods selon leurs labels. Replication controller Lorsqu’un replication controller est créé, on lui associe un template et un nombre de réplicas souhaités. Le controller s’assure du nombre minimum de réplicas souhaités dans le cluster. S’il détecte une erreur, il démarrera de lui même un nouveau replica. Kubernete Service Le load-balancer est un service proposé dans Kubernete. Celui-ci va gérer le trafic d’un ou plusieurs Pods. Lors de la création d’un service, on associe un port aux Pods sélectionnés, en se basant sur leurs labels. Une fois le service créé, tous les Pods du cluster peuvent y accéder par le port indiqué dans la configuration. Comme expliqué dans la partie sur les Managed VMs d’App Engine, le PAAS du Google Cloud devient de plus en plus souple. La prochaine étape est de déployer un conteneur docker directement dans App Engine ! Comme pour une Managed VM, il faut spécifier l’option VM à true et préciser que le runtime voulu est custom. Ce n’est pas plus compliqué que ça ! Cette fonctionnalité, non disponible à l’heure actuelle, ne devrait plus tarder.  Intégration de Docker dans App Engine Liens utiles :  https://github.com/GoogleCloudPlatform/kubernetes : GitHub de Kubernetes   http://www.slideshare.net/dotCloud/google-app-engine-at-dockercon-14 : présentation de Google sur App Engine et Docker  Conclusion Le Google Cloud propose un vaste panel de services aux développeurs et essaie de faciliter les interactions avec ceux-ci en proposant un nombre impressionnant de clients et langages différents. De plus, avec l’arrivée des Managed VMs, Google tente d’effacer l’image négative du Lockin en proposant un PAAS qui a la souplesse d’un IAAS tout en gardant les facilités de déploiement, de monitoring et de scaling automatique. En misant sur Docker, Google veut clairement être le plus standard possible. Malgré son jeune âge, Compute Engine est déjà très attractif. On sent la longue expérience de Google en matière de gestion d’infrastructure. La simplicité avec laquelle on peut monter une infrastructure en est la preuve et on a hâte de voir ce que va nous proposer Google dans un futur proche. 