2015-03-25-les-outils-de-la-data-science-r|Data|  Nous lançons aujourd’hui une série d’articles sur les outils de la Data Science. Ils auront pour objectif de présenter et expliquer les langages, les framework ou les librairies utilisés aujourd’hui par les data scientists. Nous commençons par un article sur le logiciel R. R est un logiciel d’analyse statistique open-source extrêmement populaire chez les statisticiens. Développé et maintenu par la communauté des utilisateurs, il dispose d’une librairie d’algorithmes contenue dans plus de 6000 packages disponibles gratuitement. Ces dernières années, de nombreux projets ont vu le jour pour adapter R aux problématiques actuelles de traitement et d’analyse de données. Cet article a pour objectif de présenter R et quelques opérations qu’il rend possible. Il donnera ensuite lieu à un autre article présentant les différents projets utilisant R sur des technologies Big Data, comme Hadoop ou Spark par exemple.   R est né en 1993 et a conquis le monde pour devenir l’outil le plus utilisé par les statisticiens. Il a donc un passé riche et c’est assez naturellement qu’on le retrouve dans beaucoup de projets autour des technologies Big Data. On peut notamment citer la collection de packages RHadoop permettant d’exécuter des algorithmes R sur Hadoop ou encore SparkR qui a le même rôle mais sur le framework Spark. Il est important de noter que la version 1.4 de Spark (prévue pour juin 2015) incluera une API R qui s’ajoutera aux trois APIs déjà existantes : Scala, Java et Python.  Installer R Rien de sorcier pour installer R. Tout est indiqué sur le site du projet. C’est sur ce site que sont répertoriés et documentés tous les packages R. Pour Mac et Windows R s’installe comme tous les autres logiciels. Pour Linux une simple ligne de commande est nécessaire, mais différentes selon les distributions. Pour Red Hat : sudo yum install R Pour Ubuntu : sudo apt-get install r-base Pour chacun des OS, un environnement de développement différent par défaut est mis à disposition. Aucun d’entre eux n’est vraiment beau, user-friendly ou ergonomique. Pour les distributions Linux c’est en ligne de commande, pour les deux autres c’est un peu plus élaboré mais loin d’être agréable (pas de coloration syntaxique pour windows, une fenêtre par script ouvert etc…). Cet aspect a souvent été reproché à R et a longtemps été son gros point faible. Cependant depuis quelques années un IDE est sorti du lot et offre ainsi un environnement agréable pour développer : RStudio (disponible sur tous les systèmes d’exploitations). Nous ne pouvons que vous recommander de l’installer. Il existe une version gratuite ainsi que des offres entreprises. L’avantage de cet IDE est de disposer d’une version serveur permettant d’utiliser R via une interface web. Il permet d’avoir une bonne vision de tous les travaux en cours. L’écran est divisé en 4 fenêtres : les scripts et les tables sont en haut à gauche, la console en bas à gauche, toutes les variables sont listées en haut à droite et enfin la fenêtre inférieure droite contient les graphiques et la documentation. Prendre en main R  R met à disposition une console interactive. Tout le code est exécuté via cette console. Il est possible (et indispensable) de développer ses programmes dans un fichier à part et de les exécuter ensuite. Le transfert de code entre le fichier et la console est plus ou moins pratique en fonction des IDE. Il est très simple et intuitif avec RStudio et l’IDE de Windows (Ctrl+R pour exécuter une ligne de code), l’est beaucoup moins avec celle d’OS X et n’existe pas du tout sur Linux (nécessité de faire un copier-coller du fichier vers la console). Les bases R va évaluer toute commande passée dans la console et afficher le résultat > 1 + 1  [1] 2 On assigne une valeur à une variable à l’aide de l’opérateur   <-   (l’opérateur   =   peut également être utilisé, voir cet article pour une explication): > x <- 42 Une fonction est appelée en tapant son nom, suivi par un ou plusieurs arguments entre parenthèses > sum(1, 2, 3)  [1] 6 Les Data Types Numbers L’equivalent du type double. R inclut par défaut un grand nombre de fonctions mathématiques. > sqrt(25)  [1] 5  > X <- 10  > X^2  [1] 100 Strings ou character Elles sont définies à l’aide des guillemets > a <- "hello" Logical L’equivalent du type booléen (à noter les majuscules et l’équivalence entre T <=> TRUE, F <=> FALSE) > 2 + 2 == 5  [1] FALSE  > T == TRUE  [1] TRUE Vectors Un vecteur est une séquence d’éléments de données du même type. On peut créer des vecteurs à l’aide de la fonction   c   (pour   combine  ) > c(4, 9, 3)  [1] 4 9 3 Il est également possible de créer un vecteur de nombres à l’aide de la notation start:end ou de la fonction seq > 1:3  [1] 1 2 3 On peut obtenir la valeur d’un élément d’un vecteur en déclarant un index entre deux crochets (Attention: R est un langage 1-indexé !!!) > myVector <- c(4, 9, 3)  > myVector[2]  [1] 9 Vous pouvez utiliser un vecteur dans les crochets pour accéder à plusieurs valeurs > myVector <- c(4, 9, 3)  > myVector1  [1] 4 3 assigne des valeurs dans un vecteur. R inclut par défaut un grand nombre de fonctions et d’algorithmes statistiques. Par exemple :  > myVector <- c(1,2,3,4,5)  > mean(myVector)  [1] 3  > sd(myVector)  [1] 1.581139  Factors Les factors peuvent être comparés à des enums. Ils sont notamment utilisés pour la prédiction d’une variable qualitative. Ils permettent, à l’inverse des Vectors, de connaître ses modalités. > myFactor <- factor(c("yes", "yes", "no", "yes", "no"))  > levels(myFactor)  [1] "no"  "yes" Matrix Une matrice peut être créée de la façon suivante : > myMatrix <- matrix(data = c(1, 2, 3, 4, 5, 6), nrow = 2)  > myMatrix       [,1] [,2] [,3]  [1,]    1    3    5  [2,]    2    4    6    Il est possible de renommer les lignes et les colonnes : > colnames(myMatrix) <- c("a", "b", "c")  > rownames(myMatrix) <- c("x", "y")  > myMatrix    a b c  x 1 3 5  y 2 4 6    Les données sont récupérées de la façon suivante : > myMatrix[, 1]  x y   1 2   > myMatrix[, "a"]  x y   1 2   > myMatrix[2, 3]  [1] 6  > myMatrix["y", "c"]  [1] 6 Data Frames Les DataFrames sont des sortes de matrices où chaque colonne peut avoir son propre type (ce qui n’est pas le cas des matrices dont tous les éléments doivent avoir le même type). C’est un modèle de données très populaire et extrêmement utilisé. Typiquement les données importées depuis un fichier extérieur (cvs, xls etc…) sont stockées dans un Data Frame. Les données sont lues de la façon suivante : > myData <- read.table("/path/to/my/file.csv", header = T, sep = ",") En plus de l’adresse du fichier, un booléen précisant si les données contiennent un header et le caractère séparant les variables sont précisés. Il est également possible de créer un Data Frame depuis R : > myData <- data.frame(name = c("pierre", "paul", "jacques", "pierre"), age = c(30,25,40,35))  > myData       name age  1  pierre  30  2    paul  25  3 jacques  40  4  pierre  35 La sélection des données se déroulent de la même façon que les matrices. Il y a toutefois une autre option très pratique et plus propre pour la sélection des colonnes : > myData$name  [1] pierre  paul    jacques pierre   Levels: jacques paul pierre Il est important de noter que par défaut les variables contenant des chaines de caractères sont automatiquement transformées en Factor par R. Pour modifier ce paramètre il suffit d’ajouter le paramètre suivant : > myData <- data.frame(name = c("pierre", "paul", "jacques", "pierre"), age = c(30,25,40,35), stringsAsFactors = FALSE) Il est très simple de rajouter des lignes ou des colonnes à un Data Frame : > myData <- cbind(myData, weight=c(75,80,65,70))  > myData <- rbind(myData, c("jean", 50, 85))  > myData       name age weight  1  pierre  30     75  2    paul  25     80  3 jacques  40     65  4  pierre  35     70  5    jean  50     85 Enfin l’export d’un data frame se réalise de la façon suivante : > write.table(myData, "/path/to/my/outputFile.csv", sep=",") Les packages Comme expliqué plus haut, la puissance de R se trouve dans les packages développés par la communauté des utilisateurs. Pour installer un package c’est très simple : > install.packages("packageName")  Cette commande télécharge et installe le package demandé ainsi que tous les packages dépendants. Vous pouvez trouver tous les packages sur le CRAN, le site du projet, sorte de Maven repository pour R. Cette commande n’a besoin d’être exécutée qu’une seule fois, en revanche à chaque nouvelle session il vous faudra charger le package installé : > library(packageName) Attention : le nom du package doit être entre guillemets pour l’installation mais ne doit pas l’être pour le chargement. Une fois ceci fait vous avez accès à toutes les fonctions du package chargé. Un très bon article présente R de façon très détaillée. Vous pouvez le consulter pour plus de précision sur les opérations de base de R. Nous allons maintenant montrer comment réaliser une analyse statistique plus poussée. Petite mise en situation  Nous allons utiliser un jeu de données très classique du machine learning : Iris. Il est disponible avec R et doit être chargé de la façon suivante : data(iris) Un grand nombre d’autres jeux de données sont disponibles dans le package dataset. Vous pouvez afficher la liste comme ceci : data() Vous pouvez visualiser les données très simplement : iris Le jeu de données est assez simple, 4 variables quantitatives représentant les largeurs et longueurs des pétales et des sépales de différents iris. Une cinquième variable donne le type d’iris. Il y a trois types d’iris : setosa, versicolor et virginica. Il y a 50 modalités pour chaque type. L’objectif va être de répartir les iris dans différentes classes (que l’on appelle des clusters) à partir des données quantitatives et essayer de regrouper les iris du même type dans un même classe. Pour cela nous allons utiliser un algorithme très classique du machine learning : les K-means. Cet algorithme permet de trouver des groupes dans un jeu de données (clustering). Il prend en entrée une liste de points et un nombre de clusters. Il assigne ensuite chacun de ces points à un cluster. Cette assignation est réalisée de manière à minimiser les distances des points au centre de gravité de leur cluster. Pour visualiser l’algorithme k-means voir ce site. Pour plus de précision vous pouvez consulter cet article. Pour cet exemple nous allons utiliser deux variables : la longueur et la largeur d’un pétale. Elles ont été représentées dans le graphique ci-dessous :   On voit clairement des démarcations entre les différentes espèces, les versicolor et les virginica se chevauchant un peu. Vous pouvez tracer ce graphique grâce aux commandes suivantes : plot(iris[iris$Species=="setosa",]$Petal.Length, iris[iris$Species=="setosa",]$Petal.Width, col="blue", xlab = "Longueur d'un pétale", ylab = "Largeur d'un pétale", main="Pétales d'iris", xlim=c(1,7), ylim=c(0,2.5))  lines(iris[iris$Species=="versicolor",]$Petal.Length, iris[iris$Species=="versicolor",]$Petal.Width, col="red", type="p")  lines(iris[iris$Species=="virginica",]$Petal.Length, iris[iris$Species=="virginica",]$Petal.Width, col="green", type="p")  legend("topleft", legend = c("setosa", "versicolor","virginica"),  = c("blue", "red", "green"), pch = 1, bty = "n", pt.cex = 1, cex = 0.8, text. = "black", horiz = F, inset = c(0.1, 0.1)) Nous pouvons désormais lancer le K-means : > model  <- kmeans(iris[,(3:4)], 3) Nous appelons la fonction k-means qui est par défaut contenue dans R. Nous lui passons en paramètre les données : les 3ème et 4ème colonnes la table iris qui correspondent à la longueur et à la largeur d’un pétale, ainsi que le nombre de clusters que nous souhaitons : 3. Les résultats sont stockés dans la variable model. Il est désormais intéressant de regarder comment l’algorithme a classé nos données. Pour cela nous exécutons la commande suivante : > tableau <- table(model$cluster, iris[,5]) model$cluster est un vecteur donnant pour chaque donnée le cluster auquel elle a été associée. iris[,5] donne pour chaque iris son type. > tableau         setosa versicolor virginica    1      0         49         5    2      0          1        45    3     50          0         0 Les observations notées à la vue du graphique se retrouvent ici : Toutes les setosa ont été regroupées dans le même cluster, et quelques versicolor et virginica se retrouvent dans le mauvais cluster. Avec 6 données mal classées sur 150, on obtient un taux de bien classé égal à 96%, un très bon résultat.    Aller plus loin Pour pousser les études plus loin en utilisant des algorithmes plus complexes et plus performant il est nécessaire d’utiliser des packages. Il en existe beaucoup et globalement chaque algorithme a son package, développé par des personnes différentes. C’est un peu ce qui est reproché à R. Cependant un package regroupant un très grand nombre d’algorithmes existe et est très apprécié des utilisateurs : le package caret. Il fournit un très grand nombre d’algorithmes de machine learning. Il a la particularité d’être construit comme les algorithmes de la librairies MLlib : une fonction train pour la construction du modèle et une fonction predict pour la vérification. Un autre aspect très important de la Data Science est la visualisation. Les outils de visualisation de données fournis avec R sont très basiques et pas vraiment esthétiques. Le package ggplot2 est très complet, très apprécié et permet de réaliser de très beaux graphiques.  Conclusion    Malgré les reproches qui lui sont faits, R a tout de même de beaux arguments à faire valoir notamment grâce à sa communauté très active et sa facilité de prise en main et d’utilisation. Tout est souvent mis en oeuvre pour s’adapter à ses utilisateurs. Les plus gros projets tournant autour des technologies Big Data l’ont bien compris et un prochain article sera consacré à présenter les projets intégrant R à ces technologies comme RHadoop, SparkR ou encore H20.  Bibliographie Le site du projet R : http://cran.r-project.org Pour apprendre de manière ludique : http://tryr.codeschool.com La bible francophone de R :http://www.duclert.org     