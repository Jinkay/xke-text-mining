2015-10-16-swift-2-et-les-protocol-extensions|iOSMobile|  Swift 2 est disponible et avec lui, de nombreuses nouveautés dans le langage sont apparues. L’une des plus intéressantes est certainement Proto Extension. Derrière ce nom quelque peu barbare se cache en fait une fonctionnalité très simple : la possibilité d’étendre un protocole, de la même manière que l’on peut étendre une classe.  À quoi ça sert ? Vous avez certainement déjà connu ce genre de situation : vous implémentez un protocole sur plusieurs classes, puis vous vous rendez compte que la majorité du code est dupliquée. proto Bettable {      var myBet: Int { get set }      var min: Int { get set }        func isBettable() -& ;gt; Bool  }    struct MyStruct: Bettable {      func isBettable() -> Bool {          return self.myBet > 0 && self.myBet > self.min      }  }    struct MyStruct2: Bettable {      func isBettable() -& ;gt; Bool {          return self.myBet & ;gt; 0 & ; ;& ; ; self.myBet & ;gt; self.min // duplication      }  } Vous vous retrouvez alors avec deux choix :  Garder le code dupliqué Créer une classe abstraite  Si les deux propositions sont techniquement fonctionnelles, elles ont chacune leur lot d’inconvénients : maintenance difficile, risque de bug, incohérence de la hiérarchie… Avec Swift 2 apparaît une alternative : les Proto Extensions. Au lieu d’implémenter la définition de la méthode dans une classe, celle-ci est implementée directement au niveau du protocole ! Le fonctionnement est simple : comme pour une classe (en Swift 1 et en Objective-C), vous pouvez déclarer une ou plusieurs extensions sur un protocole afin de l’implémenter : proto Bettable {      var myBet: Int { get set }      var min: Int { get set }        func isBettable() -& ;gt; Bool  }    extension Bettable {      func isBettable() -& ;gt; Bool {          return self.myBet & ;gt; 0 & ; ;& ; ; self.myBet & ;gt; self.min      }  }    // Pas de duplication !  struct MyStruct: Bettable {    }    // Pas de duplication !  struct MyStruct2: Bettable {    } Vous évitez ainsi la duplication de code. Mieux encore, aucun héritage n’a été nécessaire : les classes se conformant au protocole ont automatiquement récupéré la définition ! Les propriétés des Proto Extensions Partialité  Un concept très intéressant d’une proto extension est que vous pouvez l’implémenter partiellement : vous n’êtes pas obligés d’offrir une implémentation par défaut de toutes les méthodes. proto Awesome {      func isAwesome() -& ;gt; Bool      func isNotAwesome() -& ;gt; Bool  }    // nous ne savons pas comment implémenter isAwesome pour tous les cas  // par contre il est très vraisemblable que isNotAwesome soit juste l’opposé de isAwesome  extension Awesome {      func isNotAwesome() -& ;gt; Bool {          return !self.isAwesome()      }  } Cela permet d’atteindre deux résultats intéressants :  Avoir une alternative à l’annotation @optional des protocoles qui n’est pas disponible en Swift Utiliser l’extension proto comme   abstract class   en implémentant le code commun dedans  Generics  Vous pouvez définir des contraintes pour appliquer vos extensions grâce aux Generics. Vous pouvez ainsi définir une même extension pour plusieurs cas de figure ! /**  Définit la méthode indexOf pour les classes respectant le protocole CollectionType  la méthode ne sera disponible que lorsque les éléments de la collection sont eux-même de type Equatable  */  extension CollectionType where Generator.Element : Equatable {      public func indexOf(element: Generator.Element) -& ;gt; Index? {          for i in self.indices {              if self[i] == element { // contrainte Equatable                  return i              }          }            return nil      }  } Vous pouvez également utiliser le mot clé Self afin de pouvoir adapter vos extensions en fonction de la classe qui adaptera le protocole. proto Loggable {      func log()  }    extension Loggable where Self:String {      func log() {          print(self.description)      }  } Une condition à respecter cependant : le type utilisé dans la clause where se doit d’être une classe ou un protocole. Exit donc les enum ou les struct. Conflits Swift est assez intelligent pour vous indiquer lorsqu’il y a conflit entre deux extensions sur un type. Cela se matérialise par une erreur à la compilation, mais sous forme très générique :   Type 'C' does not conform to proto 'A'  . proto A {      func sayHello()  }    proto B {      func sayHello()  }    extension A {      func sayHello() {          print(& ;quot;hello #A& ;quot;)      }  }    extension B {      func sayHello() {          print(& ;quot;hello #B& ;quot;)      }  }    struct C : A, B { // le compilateur vous affichera & ;quot;Type 'C' does not conform to proto 'A'& ;quot;. Pareil pour 'B'.  } En revanche, aucun souci lorsque vous faites de l’héritage de protocole, Swift comprend quelle méthode utiliser !  // Même code que l'exemple précédent, mais cette fois-ci  // B hérite de A  proto B : A {      func sayHello()  }    // Nous pourrions marquer C : B, mais ici nous montrons que A ne rentre pas en conflit avec B  struct C : A, B {  }    let c = C()  c.sayHello() //  affiche & ;quot;hello #B& ;quot; Conclusion Swift 2 ouvre la porte vers une nouvelle manière de programmer au travers des proto extension. Plus qu’une simple solution pour limiter la duplication de code, les proto extension vont réellement vous simplifier la vie. N’hésitez pas à regarder la vidéo Protocol-Oriented Programming in Swift de la WWDC 2015 pour en savoir plus dessus.   