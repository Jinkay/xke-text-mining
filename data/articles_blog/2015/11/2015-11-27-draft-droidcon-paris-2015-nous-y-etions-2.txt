2015-11-27-draft-droidcon-paris-2015-nous-y-etions-2|AndroidMobile|  Xebia a encore une fois participé à la Droidcon :) . Nous vous proposons dans cet article un résumé des présentations qui ont ponctué ces deux jours.  Performance matters Les utilisateurs suppriment les applications consommatrices de batterie. Partant de ce constat, Ran Nachmany de Google nous a expliqué comment construire une application qui optimise sa consommation en énergie. 30?% de la batterie consommés correspondent aux fonctionnalités. 70?% correspondent aux appels réseaux, géo-location, analytics, etc. L’idée principale du talk est de changer notre façon de synchroniser les données en les téléchargeant en amont, une seule fois et ainsi limiter l’utilisation radio. Ran nous a également mis en garde contre les images trop grandes, les flux non optimisés (penser aux flatbuffers), la ré-utilisation des bitmaps. Préférez les types primitifs et remplacez les HashMaps par des SparseArray.  Mettre à jour un appareil Android, OK, mais comment ça marche ? Les secrets de l’OTA Certaines sociétés, comme Sidereo, modifient les sources d’Android afin de fournir un système d’exploitation   sur mesure  . Elles peuvent, par exemple, retirer des applications pré-installées, désactiver des capteurs ou fonctionnalités du smartphone. Pierre-Olivier Dybman a présenté ici le processus de publication d’une mise à jour afin qu’elle soit disponible nativement aux utilisateurs depuis les préférences du téléphone.  Let’s sprinkle some #PerfMatters on our ViewGroups Nous parlons encore performance avec François Blavoet de Deezer : les layouts sont pratiques et versatiles. François nous montre comment développer nos propres layouts et se concentrer sur le dessin de notre vue pour gagner en performance.De nombreux outils sont présentés : Systrace, Hierarchy Viewer. Pour gagner encore en performance, la logique de dessin des vues et du texte est codée manuellement, la résolution peut se faire dans un thread à part et le résultat est mis en cache !  Advanced Scrolling Techniques on Android Lors de ce Back To Basics, Cyril Mottier (Google Developer Expert / Captain Train) a présenté les différentes techniques de défilement (scroll) actuellement mises en place :  Le Dragging : déplacement d’un objet, ici le contenu de la vue va suivre le déplacement du doigt.   Le Flinging : déplacement rapide du doigt sur l’écran, entrainant un défilement continu, contenant une vélocité, qui ne s’arrête pas instantanément lorsque l’utilisateur retire son doigt de la surface de l’écran.  Il a ensuite détaillé les différentes implémentations du défilement au sein du SDK Android (View, TextView, ScrollView, ListView, RecyclerView), pour ensuite faire le parallèle avec la version iOS (UIScrollView et UITableView). Il a remonté le fait que la récupération du scroll est assez difficile selon la vue, Android a unifié cette méthode en introduisant un listener OnScrollChanged, ayant malheureusement un comportement assez différent en fonction de la vue appliquée. Il a terminé sa présentation en expliquant comment gérer la présence d’une vue qui peut défiler au sein d’une autre et quels problèmes cela pouvait remonter. Vous mesurez la vélocité d’un déplacement à la main ? Il existe VelocityTracker qui le fait pour vous. La classe EdgeEffect permet facilement de reproduire l’effet tiré lorsqu’on arrive à la fin d’une liste.  Aspect Oriented Programming Présenté par Xavier Gouchet (Deezer) lors des barc s, l’aspect oriented programming, mis en place avec AspectJ, permet d’éviter de créer et maintenir du code n’ayant que de la valeur métier. Il explique que dans notre code la plupart de nos méthodes fonctionnelles étaient englobées par des appels vérifiant que nous étions bien dans le thread d’affichage, ou qu’une NullPointerException n’était pas levée, ce qui rend le code beaucoup moins lisible. Par la création d’annotations, par exemple @MainThread, et d’une classe MainThreadAspect, contenant des méthodes de transformation d’appels, le plugin AspectJ modifiera le code afin d’injecter le comportement souhaité. @HandleNullPointer  @DebugLog  @MainThread  public void usefulMethod(){      //votre code métier  }  Application testing and Continuous Integration with Genymotion Genymotion, société française fournissant un émulateur performant ainsi qu’un SDK permettant permettant de modifier le comportement de nos capteurs (GPS, accéléromètre, etc.) nous a présenté la prochaine version de leur outil, maintenant orienté industrialisation. Ils ont comprit l’intérêt fort des développeurs à vouloir effectuer des tests d’intégration depuis un outil de CI, tel que Jenkins, et les difficultés actuellement rencontrées avec les émulateurs ou scripts actuels. Ainsi, ils ont sorti un plugin gradle permettant de créer   à la volée   des émulateurs, afin d’effectuer nos tests d’interface graphique (prenons l’exemple d’Espresso), tout en gardant la totalité des fonctionnalités offertes par Genymotion.  Android CI in the cloud Louis Davin d’OCTO nous propose un tour d’horizon des solutions d’intégration continue dans le cloud. CloudBees et Travis CI semblent les deux produits qui se démarquent le plus. Attention cependant à Cloudbees qui ne permet pas l’exécution d’émulateur Android après la version 19 (image sans doute trop grosse). Sonar et Sonar runner fonctionnera sur CloudBees.  Keynote: The Sharing Economy made Amazing by Android Quelle meilleure application que Airbnb pour illustrer l’écosystème Google ? Mark Scheel nous présente dans cette présentation tous les leviers proposés par Google et la plate-forme Android pour augmenter l’acquisition, l’expérience et l’efficacité de l’application. Quelques chiffres : 47 000 host en 2010 17 000 000 en 2015 1 000 000 visiteurs le 8 aout Comment arriver à de tels résultats ? Mark nous explique que dès le début, Airbnb a axé sa communication sur le mobile : il nous explique notamment comment les équipes de développement mettent en avant la prise des photos du bien directement dans l’application ou encore, comment créer des photosphères. Également, comment les équipes utilisent l’API Nest et l’application Airbnb pour commander le chauffage. De plus, comme Airbnb a été l’un des premiers à proposer une visite en 3D des logements grâce aux cardboards. Las de brancher, débrancher un cable HDMI sur votre TV ? Airbnb pousse les chromecasts auprès des hosts. Pour Mark, la compréhension et l’exploitation de l’écosystème Android Google a été le moteur de la croissance d’Airbnb.  Kotlin on Android Vous vous souvenez qu’il n’y a pas si longtemps, le langage à la mode sur Android était Groovy. Mais ça, c’était avant ?; maintenant le nouveau langage prometteur est Kotlin. Dans cette présentation, Svetlana Isakova de JetBrains est venue présenter le langage et les travaux de l’entreprise sur le sujet. Si vous utilisez Android Studio, alors vous connaissez déjà JetBrains (qui est l’entreprise à l’origine de l’IDE Intellij Idea, base d’Android Studio). L’intégration de Kotlin dans Android Studio est donc optimale. Le langage est moderne (lambda, stream, etc.), expressif (programmation fonctionnelle), statiquement typé (maximum d’erreurs remonté à la compilation) et a de bons outils (convertir une classe Java en Kotlin est très simple dans Intellij IDEA). Le langage est open source. Il y a un plugin Gradle pour développer en Kotlin sur Android.  Le Data Binding sur Android Android Developer a proposé depuis quelques temps une bibliothèque permettant d’associer une vue avec sa classe Java correspondante. Guillaume Bernard nous propose à travers cette présentation de voir comment utiliser cette bibliothèque. En résumé, les avantages de cette bibliothèque sont :  pas de réflexion (performance) ; le binding s’effectue à la compilation (remontée d’erreur plus rapide) ; possibilité de notifier un changement du modèle pour que la vue se mette à jour (système proche d’un binding 2 way) ; facilite l’architecture MVP on s’occupant d’associer vue et modèle.  Les inconvénients (peut être en raison de la version qui est toujours en bêta) :  l’intégration dans Android Studio n’est pas terminée (erreurs remontées qui ne sont pas des erreurs)?; auto-complétion parfois approximative ou inexistante?; à noter que Jake Wharton a tweeté qu’il n’aimait pas cette bibliothèque ?!   The Android NDK and its new support in Android Studio/gradle-experimental plugin L’équipe d’Intel, representée par Xavier Hallade (Google Developer Expert), était présente lors de cet évènement pour nous présenter le nouvel outil de support du NDK, maintenant disponible avec un plugin Gradle, offrant de nombreuses fonctionnalités autour du support natif Android (Java Native Interface). Nous avons pu observer l’utilisation du plugin Gradle sur un projet existant, ainsi que l’application du mode debugging C++, qui était très compliqué à exécuter auparavant, offrant maintenant une intégration complète au sein d’Android studio.  Eddystone : an open Bluetooth smart beacon format from Google Le monde des beacons promet d’ajouter une dimension de géolocalisation ultra-fine et personnalisée aux utilisateurs mobiles. Google fournit une gamme de protocoles et services visant à uniformiser leur utilisation, que Turhan Oz nous détaille dans cette présentation : – Eddystone: le protocole BLE ouvert, implémenté par les constructeurs majeurs. Turhan nous décrit en détail les types de paquets définis dans ce standard (UID, URL et TLM), avec un exemple d’implémentation de scanner BLE correspondant. – Google Beacon Platform : la plate-forme de gestion de beacons de google permet la centralisation de la gestion des informations liées à chaque flotte de beacons. La Proximity API permet la gestion administrateur d’une flotte de beacon, ainsi que son monitoring. – Les API client tirant parti de la plate-forme : Nearby Messages API, Places, Proximity API. Forte intégration des services, capacités de monitoring et ouverture du protocole sont les gros atouts sur lesquels mise Google pour imposer sa vision des services de proximité via beacons.  Linty Fresh Dans cette présentation, Matthew Compton (BigNerdRanch) revient en détail sur la façon de créer nos propres règles d’analyse de code statique pour Lint. Il commence par nous montrer comment mettre en place un projet de règles Lint. Il suit ensuite l’exemple concret d’une règle visant à empêcher l’utilisation d’enum dans un projet Android, afin d’expliquer comment s’articulent les 4 éléments majeurs sur lesquels s’appuie la définition de règles lint : Issue, Detector, Implementation et Registry. Il nous montre enfin comment appliquer nos règles personnalisées à nos projets. Comment développer une application en moins d’une h et de 200 lignes avec Kotlin Un speaker au top de sa forme, un langage qui attire de plus en plus de développeurs et une promesse très ambitieuse, développer une application en moins d’une heure et de 200 lignes : il n’en fallait pas moins pour faire salle comble pendant cette présentation faite par Mounir Boudraa. Après une brève description de Kotlin et de ses avantages, Mounir s’est lancé dans une séance de live coding et après seulement quelques dizaines de minutes ; contrat rempli.  Android Auto : Rolling droid gather no moss Dans cette présentation de Damien Cavaillès (Hell Rider), nous avons eu la possibilité de voir le fonctionnement du système Android Auto qui devrait faire son apparition dans nos véhicules dans les prochaines années. Bien que l’ensemble du système ne soit pas encore testable, notamment la partie liée à la gestion du véhicule (pression des pneus, entretien du moteur…) nous avons pu découvrir comment va fonctionner Android Auto, les limitations en terme de développement et l’intégration avec le système de notification et du lecteur de média.  Comment tester (vraiment) une application Android Cette présentation permet d’aborder des problèmes récurrents sur les projets Android : comment tester le code legacy. Par legacy, Thomas (Deezer) et Benjamin (Xebia) veulent parler des singletons et méthodes/classes statiques. La réponse la plus simple est de passer par des variables d’instance puis, dans les tests, de simuler le comportement grâce à Mockito. L’architecture MVP permet également de séparer les responsabilités : tests des vues et des composants Android avec Robolectric et Mockito et les algorithmes dans les Presenters avec Mockito seul. Il est expliqué qu’il est plus aisé de faire des tests lorsque le projet à été conçu avec le paradigme composition plutôt qu’héritage. La présentation se termine par la présentation d’outils pour écrire efficacement des tests : AssertJ et AssertJ Android.  C’est terminé pour nos résumés. Vous trouverez plus de vidéos directement sur le site de la DroidCon Paris. 